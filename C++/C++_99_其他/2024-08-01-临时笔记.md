---
layout: post
title:  临时笔记
date:   2024-08-01 09:00:00 +0800
categories: Personal
tag: Personal
last_modified_date: 2024-08-01 10:00:00 +0800
---

## MFC,WTL,ATL,STL联系与区别

+ C++是一门语言，它与平台无关。只要能提供C++编译器(或者交叉编译器)的平台，就能使用C++变成。基本上常见的操作系统都有C++编译器或者交叉编译器。
+ VC++，不是语言，而是一个工具软件。他甚至不是编译器，而是一个开发环境(VC++的编译器实际上只是一个可执行文件cl.exe)，用这个环境能帮你用C++快速的开发出各种win32的程序。
+ C++具有语言标准，这个标准由ISO批准的。所谓标准就是任何C++编译器都应该遵守的，包括cl.exe。所以，学好标准的C++就能再任何平台上开发。但是各个编译器除了支持标准外，还在不与标准冲突的范围内进行了语法扩充，当然是为了能够更高效方便的开发程序。
+ 只有语言能做的事情非常少，在操作系统上跑需要各种现有的程序的支持，这些支持通常以库的形式表现出来。例如C标准库，C++标准库。这两个是标准的。非标准的就像所说的MFC之类的。
+ 下面比较这几个库

### STL(标准模板库)

+ STL的代码从广义上讲分为三类：algorithm(算法)，container(容器)和iterator(迭代器)

### ATL(活动模板库)

+ ATL，ActiveX Template Library. 是一个产生C++/COM代码的框架，就如同C语言是产生一个汇编代码的框架。ATL又不同于MFC，它完全面向COM组件，其技术路线也不同于MFC。
+ MFC使用的是C++中的继承，封装，嵌套等常规技术，而ATL使用了C++中模板，多继承等高级技术，甚至还用到了STL
+ COM component(COM组件)，是微软公司为了计算机工业的软件生产更加符合人类的行为方式开发的一种新的软件开发技术。在COM构架下，人们可以开发出各种各样的功能专一的组件，然后将他们按照需要组合起来，以便随时进行系统的升级和定制；可以在多个应用系统中重复利用同一个组件；可以方便的将应用系统扩展到网络环境下

### WTL(Windows Template Library)

+ WTL，构架于ATL之上，采用C++模板技术来包装大部分窗口控制，并给出一个与MFC相似的应用框架。

### MFC

+ MFC，Microsoft Foundation Classes. 实际上是微软提供的，用于在C++环境下编写应用程序的一个框架和引擎。
+ VC++是Windows下开发人员使用的专业C++ SDK(SDK, Standard SoftWare Develop Kit,专业软件开发平台)，MFC就是挂在它之上的一个辅助软件开发包。
+ **注意C++与VC++的区别**：
  + C++是一种程序设计语言，是一种大家都承认的软件编制的通用规范
  + VC++只是一个编译器，或者说是一中编译器＋源程序编辑器的IDE
+ MFC是Win API与C++的结合。API，即微软提供的Windows下应用程序的编程接口，是一种软件编程的规范，但不是一种程序开发语言本身，可以允许用户使用各种各样的第三方的编程语言对Windows下应用程序的开发，是这些被开发出来的应用程序能在Windows下运行，比如VB，VC++，Java，Delphi。
+ 编程语言函数本质上全部源于API，因此用他们开发出来的应用程序都能工作在Windows的消息机制和绘图里，遵循Windows作为一个操作系统的内部实现，这其实也是一种必要。微软如果不提供API，这个世界上对Windows编程的工作就不会存在，微软的产品就会迅速从时尚变为垃圾。
+ 上面说到MFC是微软对API函数的专用C++封装，这种结合一方面让用户使用微软的专业C++ SDK来进行Windows下应用程序的开发变得很容易，因为MFC是对API的封装，微软做了大量的工作，隐藏了好多程序开发人员在Windows下用C++ & MFC编制软件时的大量细节，例如应用程序实现消息的处理，设备环境绘图，这种结合是以方便为目的的，必定要付出一定代价，因此就造成了MFC对类封装中的一定程度的冗余。
+ 最后要明白MFC不只是一个功能单纯的界面开发系统，它提供的类绝大部分用来进行界面开发，关联一个窗口的侗族，但它提供的类中也有好多类不与一个窗口关联，即类的作用不是一个界面类，不实现一个窗口对象的控制，而是一些在Windows中实现内部处理的类，例如数据库的管理类等。学习中最应该花费时间的是消息和设备环境，对C++和MFC的学习中最难的部分是指针，C++面向对象程序设计的其他部分，例如数据类型，流程控制都不难。

## C++类的成员变量是在堆区还是在栈区

### C++内存分配基础

+ 在理解C++类的成员变量存储位置之前，我们先要了解C++中的几种主要内存区域
  + 栈区(Stack): 栈区内存由编译器自动分配和释放，存储函数的局部变量，参数等。栈区内存具有生命周期短，分配效率高的特点
  + 堆区(Heap): 堆区内存由程序员手动分配和释放(使用new和delete)。堆区内存的生命周期由程序员控制，适合存储需要长时间存在的数据
  + 静态存储区(Static Storage): 该区域存储静态数据成员和全局变量，内存分配在程序开始时进行，直到程序结束时才释放
  + 代码区和常量区: 存储程序代码和常量数据

### 类的成员变量存储位置

+ 类的成员变量的存储位置取决于类的实例(对象)如何创建。主要有以下几种情况

1. 栈上分配的对象
   + 当一个对象在栈上分配时，成员变量也存储在栈上 

2. 堆上分配的对象
   + 当使用new关键字动态分配一个对象时，对象和其成员变量会存储在堆上。 
   
3. 静态存储区的对象
   + 如果一个对象是全局变量或静态变量，那么它会被分配在静态存储区。
   + 这些对象的内存在程序开始时分配，并且在程序运行期间一直存在，直到程序结束时才会释放。因此，静态对象和全局对象的成员变量存储在静态存储区中。

## C __BEGIN_DECLS 是什么

`__BEGIN_DECLS` 和 `__END_DECLS` 是在C语言和C++代码混合时使用的宏。它们用于确保 C 头文件在被 C++ 编译器编译时能够正确处理 C 函数原型。

当在 C++ 环境中包含 C 头文件时，需要用 `extern "C"` 来告诉 C++ 编译器这些声明是 C 语言的，以便正确处理名字修饰（name mangling）。`__BEGIN_DECLS` 和 `__END_DECLS` 宏正是为了简化这一过程而设计的。

```c
#ifdef __cplusplus
# define __BEGIN_DECLS extern "C" {
# define __END_DECLS }
#else
# define __BEGIN_DECLS
# define __END_DECLS
#endif
```

这段代码的含义是：

- 如果编译器是 C++ 编译器 (`__cplusplus` 被定义)，则 `__BEGIN_DECLS` 被定义为 `extern "C" {`，`__END_DECLS` 被定义为 `}`。
- 如果编译器是 C 编译器，则这两个宏都定义为空。

使用这些宏可以这样写一个头文件：

```c
#ifndef MY_HEADER_H
#define MY_HEADER_H

__BEGIN_DECLS

void my_function();

__END_DECLS

#endif // MY_HEADER_H
```

当这个头文件在 C++ 代码中被包含时，`my_function` 的声明会被包含在 `extern "C"` 块中，从而避免了 C++ 名字修饰问题。在 C 代码中，宏会被定义为空，所以对代码没有影响。